Test/ExprParser«import«Parsec/Many»¸ "# Parsing Arithmetic Expressions

A common way to demonstrate parser construction is to use a grammar that represents arithmetic expressions. We build a parser for simple expressions that consist of addition, subtraction, multiplication, and division operations."¸ type«"## Tokens

Tokens include numbers, parenthesis, operators, and whitespace."¸ data«ExprToken¸ |«.Number«1»¸ .OpenParen«2»¸ .CloseParen«3»¸ .Plus«4»¸ .Minus«5»¸ .Multiply«6»¸ .Divide«7»¸ .Whitespace«8»¸ .EOF«9»»»»¸ instance«"We need to define equality for ExprTokens. We use the strict value equality here."¸ Eq«ExprToken¸ ==«===»¸ !=«!==»»»¸ const«"## Lexer

The lexer can be constructed with a single expression. We specify the regular expression that accepts a given token, and associate it to the member of the enumeration defined above."¸ lexer«Lexer«ExprToken»¸ newLexer«[«.Token«.Number¸ "-?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?"»¸ .Token«.OpenParen¸ "\("»¸ .Token«.CloseParen¸ "\)"»¸ .Token«.Plus¸ "\+"»¸ .Token«.Minus¸ "-"»¸ .Token«.Multiply¸ "\*"»¸ .Token«.Divide¸ "\/"»¸ .Token«.Whitespace¸ "[\t\n\r ]+"»¸ .Token«.EOF¸ "$"»»»»¸ "## Parser

Parser is built from two kinds of parsing rules: ones that recognize terminals and others that recognize nonterminals.

### Terminals

Terminal parsers recognize the tokens returned by the lexer. They are straightforward to define.

First we define a parser that skips any whitespace between the tokens.
"¸ optws«optional«terminal«.Whitespace¸ "<whitespace>"»»»¸ "Next we define parser for numbers. We convert the recognized text to Number type. We skip the trailing whitespace with the `followedBy` combinator."¸ number«Parser«Number¸ Token«ExprToken»»¸ followedBy«_map«terminal«.Number¸ "<number>"»¸ ->«.Token«_¸ text»¸ _read«text»»»¸ optws»»¸ "Parenthesis and operators are all recognized the same way. Again, we skip the trailing whitespace to keep the other rules simple."¸ openParen«followedBy«terminal«.OpenParen¸ "("»¸ optws»»¸ closeParen«followedBy«terminal«.CloseParen¸ ")"»¸ optws»»¸ plus«followedBy«terminal«.Plus¸ "+"»¸ optws»»¸ minus«followedBy«terminal«.Minus¸ "-"»¸ optws»»¸ multiply«followedBy«terminal«.Multiply¸ "*"»¸ optws»»¸ divide«followedBy«terminal«.Divide¸ "/"»¸ optws»»¸ "`eof` is a special terminal parser that recognizes end of input."¸ eof«terminal«.EOF¸ "<end of input>"»»¸ "### Nonterminals

The abstract nodes in a syntax tree are called nonterminals. We define a parser for each nonterminal. Since expressions can theoretically be infinitely long, the parsers are recursive.

First we define parsers for operators. We utilize the operators combinator which is designed just for this purpose. These parsers calculate the result of the operation, and return it to the parent parser."¸ addop«Parser«->«Number¸ Number¸ Number»¸ Token«ExprToken»»¸ operators«[«(«plus¸ ->«a¸ b¸ +«a¸ b»»»¸ («minus¸ ->«a¸ b¸ -«a¸ b»»»»»»¸ mulop«Parser«->«Number¸ Number¸ Number»¸ Token«ExprToken»»¸ operators«[«(«multiply¸ ->«a¸ b¸ *«a¸ b»»»¸ («divide¸ ->«a¸ b¸ /«a¸ b»»»»»»¸ "Expressions consist of terms that are added or subtracted together. Note how the grammar implicitly defines the precedence order as terms are recognized before the expressions.

"¸ expr«Parser«Number¸ Token«ExprToken»»¸ forwardRef«\«chainOneOrMore«term¸ addop»»»»¸ "To change the precedence order we uses parenthesis as usual. When an expression is surrounded by parentehesis it becomes a factor which is recognized before terms. So, a factor is either a number or an expression in parenthesis."¸ factor«Parser«Number¸ Token«ExprToken»»¸ or«bracketedBy«expr¸ openParen¸ closeParen»¸ number»»¸ "Last define a term as sequence of factors separated by multiplication or division operators."¸ term«Parser«Number¸ Token«ExprToken»»¸ chainOneOrMore«factor¸ mulop»»¸ "Last we define the root parser, which just skips any leading whitespace before calling the expression parser. Whitespace in-between tokens is skipped by terminal parsers."¸ rootExpr«Parser«Number¸ Token«ExprToken»»¸ followedBy«>>«optws¸ expr»¸ eof»»¸ "## Evaluating String Expressions

Now we can define the functions which parses an expression string and calculates its value. To get a `ParserInput<ExprToken>` interface required by the parser, we call the `lexerInput` function, which takes the lexer and input expression as arguments.

After that we can call the `parse` function which takes the root grammar rule and the input as parameters."¸ evaluateExpression«->«String¸ Number»¸ ->«input¸ parse«rootExpr¸ lexerInput«input¸ lexer¸ .Token«.EOF¸ "<end of input>"»»»»»¸ testExpr«evaluateExpression«"(1 + 213) * 2"»»»»